---
layout: post
title: '초간단 실시간 감시기 만들기 (1)'
author: Bo-Seung Ko
date: 2020-05-18 07:00
tags: [kicomav,opensource,driver]
---

<fieldset style="margin:0px 0px 20px 0px;padding:5px;"><legend><span><strong style="font-weight:bold;">연재 순서</strong></span></legend><!--Creative Commons License--><div style="float: left; width: 88px; margin-top: 3px;"><img alt="Creative Commons License" style="border-width: 0" src="/files/images/exclamationmark.png"/></div><div style="margin-left: 92px; margin-top: 3px; text-align: justify;">
<p style="margin: 0; background:#ddd;">첫번째 글: 실시간 감시기란</p>
<p style="margin: 0;"><a href="/2020/05/25/kicomav_driver_2/">두번째 글: 미니필터 드라이버를 사용하여 실시간 파일 I/O 확인하기</a></p>
<p style="margin: 0;">세번째 글: KicomAV 엔진을 사용하여 유해한 파일인지 확인하기</p>
</div></fieldset>


## 실시간 감시기란

과연 실시간 감시기란 무엇일까? 일반적으로 실시간 감시기는 시스템 이벤트가 발생할 때 유해 여부를 검사하여 유해한 것은 차단하고 그렇지 않은 것은 허용하는 프로그램을 일컫는다. 윈도우 환경이라면 시스템 이벤트는 파일 연산, 레지스트리 연산, 프로세스/스레드 연산, 네트워크 연산 등으로 다양하다. 그리고 파일 연산을 좀 더 구체화하면 파일의 생성, 읽기, 쓰기, 이름변경, 이동, 삭제, 등등 여러가지 연산을 수행하게 된다. 그리고 이러한 연산을 수행하는 주체는 프로세스이다. 시스템 이벤트의 유해성 여부는 보통 백신 엔진이라고 하는 진단기능에서 판단한다. 일반적으로 백신 엔진은 파일 경로를 입력으로 받고 그 결과로 유해성 여부를 출력한다. 유해하다고 판단된 경우에 백신 엔진은 해당 파일을 삭제하는 기능을 제공하기도 한다.

![실시간 감시기 개요](/files/driver1_1.png)

국내 백신 프로그램인 V3, 바이로봇, 알약이나 해외 제품인 카스퍼스키, 맥아피 등의 백신 프로그램들은 거의 대부분 실시간 감시기 기능을 제공한다. 하지만 각 제품마다 시스템 이벤트를 다루는 방식과 백신 엔진의 구조는 아마도 많이 다를 것이고 이러한 차이점이 백신 제품의 성능 및 진단율에 영향을 준다.

## 우리가 만들 실시간 감시기

관련 업계 종사자가 아니라면 실시간 감시기 만들기는 꽤나 높은 진입장벽을 가지고 있다. 악성코드가 어떤 방식으로 실행되었는지, 시스템의 어떤 자원을 감염시키는지, 어떻게 하면 악성코드를 치료할 수 있는지를 이해하고 대응할 수 있어야 한다. 이를 위해서 우선 운영체제에 대한 깊은 이해를 바탕으로 프로세스의 실행 과정과 이 시점에 어떤 시스템 자원(파일 및 레지스트리 등)을 참조하는지 모니터링 할 수 있어야 한다. 그리고 모니터링으로 확인한 정보(보통은 파일 경로이다.)를 사용하여 해당 연산을 허용하거나 차단할 수 있어야 한다. 이러한 차단 여부를 판단할 때 사용하는 것이 백신 엔진이다. 실시간으로 시스템 이벤트를 다루는 것은 시스템 성능에 영향을 줄 수 있기 때문에 무조건 많은 이벤트를 다루는 것이 능사는 아니다. 최소한의 시스템 이벤트를 검사하여 악성코드의 동작을 막는 것이 가장 좋다.

제목에서도 알 수 있듯이 우리는 아주 간단한 실시간 감시기를 만들 것이다. 기능을 요약하자면 아래와 같다.

- 운영체제: Windows 7 이상
- 시스템 이벤트: 미니필터 드라이버를 사용하여 파일 Open 연산 모니터링
- 백신 엔진: KicomAV 엔진을 사용하여 유해여부 진단

이번 연재의 목표는 공개된 소스코드를 활용하여 아주 간단한 실시간 감시기를 만들어보고 그 동작 방식을 이해하는 것이다.

## 파일 연산 모니터링하기

앞서 기능 요약에서도 언급했듯이 시스템 이벤트는 파일 Open 연산 만을 그 대상으로 할 것이다. 그리고 그 방법은 윈도우 운영체제에서 제공하는 미니필터 드라이버 방식을 사용할 것이다. 파일 연산을 모니터링 하기 위한 방법은 아래와 같이 다양하다.

- 유저레벨 파일 연산 API 후킹
- 레거시 파일시스템 필터 드라이버
- 미니필터 드라이버

우선 유저레벨에서 파일 연산 API 후킹 방식은 말 그대로 임의의 프로세스에 API 후킹 모듈을 삽입하여 파일 연산 API를 후킹함으로써 파일 연산을 모니터링 하는 것이다. 이 방법은 실시간 감시기가 동작을 시작할 때 이미 실행중인 프로세스에 대해서 API 후킹 모듈을 삽입해야 한다. 그리고 새롭게 실행되는 프로세스에 대해서는 프로세스 생성 시점에 API 후킹 모듈을 삽입해야 한다. 이 시점은 상당히 중요하다. 어떤 프로세스가 어느 시점에 악성코드를 실행시킬지 모르기 때문이다.

![API 후킹](/files/driver1_2.png)

유저레벨에서 각각의 프로세스에 API 후킹 모듈을 삽입하는 것은 타겟 프로세스에게 있어서는 불쾌하게 받아들여질 수도 있다. 또는 응용 프로그램은 API 후킹 모듈 삽입으로 인해서 크래시가 발생할 수도 있다. 가장 안좋은 것은 타겟 프로세스가 자가 보호 기능을 가지고 있는 경우이다. 이 경우 API 후킹 모듈 삽입 자체가 실패하여 시스템 이벤트를 수집할 수 없기 때문이다. 그래서 거의 대부분의 백신 프로그램에서는 API 후킹 방식으로 수집한 시스템 이벤트를 백신 엔진에 던지기 위한 용도로 사용하지는 않는다. 대신 특정 프로세스를 지정하여 행위 엔진이나 프로그램 가상화 용도로 사용한다.

레거시 파일시스템 필터 드라이버는 ntfs.sys 나 fastfat.sys 와 같은 파일시스템 드라이버를 WDM(Windows Driver Model) 구조에 입각하여 필터링 하는 드라이버이다. 이 방식은 미니필터 방식이 보편화되기 전에 많이 사용하던 방식이다. 일단 유저레벨이 아닌 커널레벨에서 필터링 연산을 수행하기 때문에 모든 프로세스의 파일 연산에 대해서 모니터링이 가능하다는 장점이 있다.

![레거시 파일시스템 필터 드라이버](/files/driver1_3.png)

레거시 파일시스템 필터 드라이버는 어디까지나 필터 드라이버이다. 이것은 자신의 논리적인 위치상으로 위 아래에 있는 드라이버와 안정적으로 동작해야 한다는 것을 의미한다. 만약에 사용자가 레거시 필터 드라이버를 사용하는 프로그램을 여러 개 설치한 경우에는 각각의 프로그램과 연계하여 동작하는 각각의 레거시 필터 드라이버가 존재하게 된다. 필터 드라이버를 구현할 때 주의해야 하는 것은 다양한 프로세스에서 동시다발로 발생하는 파일 연산에 대해서 시스템 성능저하를 최소화 하면서 필터링 기능을 제공해야 한다는 것이다. Windows XP 시절에는 미니필터 드라이버 못지 않게 레거시 파일시스템 필터 드라이버도 많이 사용되고 있었다. 하지만 안정화되지 않은 몇몇 레거시 파일시스템 필더 드라이버는 종종 문제를 일으켰고 심한 경우 블루스크린을 발생시키기도 했다. 이에 마이크로소프트는 구조적으로 안정화된 미니필터 드라이버를 사용하도록 권장했고 Windows 10 (1607) 에 이르러서는 레거시 파일시스템 필터 드라이버의 사용을 제한하는 정책으로 나아가고 있다[^1].

레거시 파일시스템 필터 드라이버 자체가 나쁘다는 것은 아니다. 이제부터 설명할 미니필터 드라이버는 필터 매니저(FltMgr.sys)의 관리를 받는데 필터 매니저는 레거시 파일시스템 필터 드라이버로 구현되어 있다. 그 이름에서도 알 수 있듯이 필터 매니저는 미니필터 드라이버를 관리해준다. 달리 표현하면 필터 매니저는 미니필터 드라이버가 사용할 수 있는 다양한 API를 제공해준다. 레거시 파일시스템 필터 드라이버를 구현할 때 개발자가 하나하나 신경쓰며 구현해야 했던 기능을 미니필터 드라이버는 필터 매니저에 구현된 API를 사용함으로써 편리하고 신속하게 안정적인 기능을 구현할 수 있게 되었다.

![미니필터 드라이버](/files/driver1_4.png)

필터 매니저와 미니필터 드라이버도 배포 초기에는 성능적인 면에서 개발자의 외면을 받았지만 점차 개선되어 현재 출시된 거의 대부분의 안티 바이러스 제품들은 미니필터 방식을 사용하고 있다. 그 이유는 시스템 운용 중에 드라이버의 안정적인 언로드를 보장받을 수 있고, 필요한 파일 연산에 대해서만 선택적으로 필터링 기능을 수행할 수 있으며, Altitude 라는 개념을 사용하여 안티 바이러스, 백업, 압축, 암호화, 가상화 등 파일시스템 필터 드라이버에서 구현할 수 있는 다양한 기능에 대해서 영역을 구분함으로써 제품을 관리하는 측면에서 보다 유리하기 때문이다. 필터 매니저 모델에 대한 이점 및 Altitude에 대해서는 아래의 링크에서 자세하게 확인할 수 있다.

- [Advantages of the Filter Manager Model](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/advantages-of-the-filter-manager-model)
- [Load Order Groups and Altitudes for Minifilter Drivers](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/load-order-groups-and-altitudes-for-minifilter-drivers)
- [Allocated Altitudes](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/ifs/allocated-altitudes)

## 안티 바이러스 백신 엔진

백신 엔진은 그 자체만으로도 거대한 프로그램이다. 굳이 커널레벨에서 실시간 파일 연산을 전달받지 않더라도 응용 프로그램에서 백신 엔진을 사용하여 전체 파일을 검사하거나 또는 선택적으로 파일의 유해성을 검사할 수 있다. KicomAV는 (주)누리랩의 최원혁 대표가 개발한 안티바이러스 백신 프로그램이다.  KicomAV는 오픈소스로 아래의 링크에서 확인할 수 있다.

- <https://github.com/hanul93/kicomav>

그리고 기술블로그의 “KicomAV 가이드” (<https://nurilab.github.io/2020/04/01/kicomav_guide/>) 편에서도 사용방법과 악성코드 패턴을 추가하는 방법에 대해서 자세하게 설명하고 있다.

우리는 오픈소스로 제공되는 KicomAV 백신의 진단 엔진을 사용할 예정이다. KicomAV 엔진은 파이썬으로 개발되었는데 C 나 CPP 로 구현된 프로그램에서 가져다 사용할 수 있도록 Python Embedding 기법을 사용하여 k2py(64).dll 이라는 별도의 엔진으로 변형하여 활용할 계획이다.

## 마무리

이번 글에서는 초간단 실시간 감시기를 만들기에 앞서 실시간 감시기가 어떤 것인지에 대해서 설명하였다. 그리고 시스템 이벤트를 실시간으로 어떻게 수집할 수 있는지, 그 수집된 정보의 유해성 여부를 무엇으로 판단할 수 있는지 간단하게 알아보았다. 다음 글에서는 실제 소스코드를 가지고 본격적으로 실시간 감시기 만들기를 시작하겠다.

## 참고 자료

[^1]:  Blocking legacy file system filter drivers: <https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/blocking-file-system-filter-drivers>

